"""
This module wraps the "openshift-client" library,
which is based on the "oc" CLI.
"""

import logging
from pathlib import Path
from typing import Dict, List, Callable, Optional, Union
from time import sleep, time
import openshift as oc
from openshift import context
from openshift.model import OpenShiftPythonException
from openshift.selector import Selector
from openshift import APIObject
import requests
from requests.status_codes import codes as httpCodes
from urllib.parse import urlparse
from urllib3 import disable_warnings
from urllib3.exceptions import InsecureRequestWarning


class OcClient:
    """
    Abstraction of an "oc" client pointing to a specific server,
    and optionally to a project

    :param server_url: The API url of the OCP server
    :param project: The name of project or namespace
    """

    def __init__(self, server_url: str, project: str = None):
        self.server = server_url
        self.project = project

    @classmethod
    def from_kubeconfig(cls, config_path: str, cluster_name: str):
        oc.set_default_kubeconfig_path(config_path)
        server_url = oc.config.get_kubeconfig_cluster(cluster_name)["server"]
        return cls(server_url)

    def is_api_up(self, verifyCertificate: bool = False):
        """
        Checks if the OpenShift API endpoint is alive
        """
        disable_warnings(InsecureRequestWarning)

        urlparts = urlparse(self.server)
        endpoint = f"https://{urlparts.hostname}:{urlparts.port}/version"

        try:
            response = requests.get(
                endpoint,
                verify=verifyCertificate,
                params={"timeout": "10s"}
            )
        except Exception as e:
            logging.error("OpenShift API verification failed: %s", e)
            return False

        k8s_major_version = int(response.json()['major'])
        return response.status_code == httpCodes.ok and k8s_major_version == 1

    def login(self, username, password):
        """
        Runs: oc login
        """
        with self.server_context():
            oc.login(username, password)

    def new_project(self, name):
        """
        Runs: oc new-project
        """
        with self.server_context():
            oc.invoke("new-project", [name])

    def delete_project(self, name):
        """
        Runs: oc delete project
        """
        with self.server_context():
            oc.invoke("delete", ["project", name])

    def new_app(self,
                name: str,
                project: str,
                args: List[str]):
        """
        Runs: oc new-app
        """
        with self.project_context(project):
            oc.invoke("new-app", [name] + args)

    def wait_pod_ready(self,
                       project,
                       labels={},
                       sleep_seconds=1,
                       timeout_seconds=120
                       ):
        """
        Waits until a specific pod is ready
        """
        pods = []
        start_time = time()

        with self.project_context(project):
            while len(pods) == 0:
                pods = oc.selector("pods", labels=labels).objects()
                sleep(sleep_seconds)
                if time() - start_time > timeout_seconds:
                    raise OcException("Timed out waiting for pods to exist")

            is_pod_ready = pods[0].model.status.containerStatuses[0].ready
            while not is_pod_ready:
                pods = oc.selector("pods", labels=labels).objects()
                is_pod_ready = pods[0].model.status.containerStatuses[0].ready
                sleep(sleep_seconds)
                if time() - start_time > timeout_seconds:
                    raise OcException("Timed out waiting for pods to be ready")

    def get_route(self, project, labels=None, name=None,
                  https_output=True):
        """
        Runs: oc get route
        Returns the first route that matches the given labels.

        :param project: The project or namespace that hosts the route
        :param labels: Optionall dict of labels to select the route
        :param name: Optional parameter to filter the routes by name
        :param https_output: Optional parameter to select the output format
        """
        with self.project_context(project):
            routes = oc.selector(
                'route' + (f"/{name}" if name else ''),
                labels=labels
            ).objects()

            if not routes:
                raise OcException(message="No routes found")

            if https_output is None:
                return routes[0].model.spec.host
            elif https_output:
                return f"https://{routes[0].model.spec.host}"
            else:
                return f"http://{routes[0].model.spec.host}"

    def get_sa_token(self, name: str, project: str = None):
        """
        Get Service Account token by name

        :param name: Name of the Service Account token
        :param project: The project that contains the Service Account
        """
        with self.project_context(project):
            return oc.invoke('sa', ['get-token', name]).out().strip('\n')

    def project_exists(self, project: str) -> bool:
        """
        Check if a project exists

        :param project: Name of the project
        """
        try:
            oc.invoke('get', ['project', project])
            return True
        except Exception:
            return False

    def server_context(self):
        return OCCommandContext(self.server)

    def project_context(self, project=None):
        return OCCommandContext(
            self.server, project or self.project)

    # TODO: apply_template methods should not expose internal entities,
    #  relative to the openshift-client-python library

    def apply_template(self, project: str,  template_path: Union[Path, str],
                       template_parameters=None) -> Selector:
        """
        Apply a template

        :return: (bool, objs, bad) where bool is True if the success
            condition was satisfied
            and False if the failure condition triggered.
            objs is the list of selected objects
            which were checked,
            and bad will be an non-None APIObject if an object failed
            the check.
        """
        with self.project_context(project):
            with open(template_path) as template_file:
                template = APIObject(None, template_file.read())
                return oc.apply(
                    template.process(template_parameters, "--local=true"))

    def apply_template_and_wait(
        self,
        project: str,
        template_path: Union[Path, str],
        template_parameters: Optional[Dict] = None,
        timeout_seconds=120.0,
        success_func: Optional[Callable] = None,
        failure_func: Optional[Callable] = None
    ):
        """
        Run "oc apply" with a template file and wait until a condition is met.

        'success_func' is a function that checks the condition to be met.
        If not provided, the success_func is node_is_ready.

        'failure_func' is a function that check for a failure.
        If 'failure_func' returns True, then this function stops polling
        and returns False.

        :return: (bool, objs, bad) where bool is True if the success
            condition was satisfied
            and False if the failure condition triggered.
            objs is the list of selected objects
            which were checked,
            and bad will be an non-None APIObject if an object failed
            the check.
        """
        if success_func is None:
            success_func = node_is_ready

        with oc.timeout(timeout_seconds):
            selector = self.apply_template(
                project,
                template_path,
                template_parameters,
            )
            return selector.until_all(
                success_func=success_func,
                failure_func=failure_func,
            )

    def delete_template(self, project: str, template_path: str,
                        template_parameters=None) -> Selector:
        with self.project_context(project):
            with open(template_path) as template_file:
                template = APIObject(None, template_file.read())
                return oc.delete(
                    template.process(template_parameters, "--local=true"))

    def extract_secret(self, project: str, secret_name: str, key: str) -> str:
        with self.project_context(project):
            secret = oc.invoke(
                'extract',
                [f"secret/{secret_name}", f"--keys={key}", '--to=-']
            )
            return secret.out()

    def apply(self, project: str, resource_path: str) -> Selector:
        with self.project_context(project):
            with open(resource_path) as resource_file:
                resource = APIObject(None, resource_file.read())
                return oc.apply(resource)

    def delete(self, project: str, kind: str, name: str):
        with self.project_context(project):
            oc.selector(
                f"{kind}/{name}"
            ).delete(ignore_not_found=False)

    def get(self, project, kind: str, name: str, labels=None):
        with self.project_context(project):
            return oc.selector(
                kind + (f"/{name}" if name else ''),
                labels=labels
            ).objects()

    def set_project(self, name):
        with self.server_context():
            oc.invoke('project', [name])


class OCCommandContext():
    """
    Execution context to use when running "oc"
    Includes a server url, and optionally a project name (namespace)
    It catches the oc.OpenShiftPythonException
    It tracks oc commands and logs the result in case of error
    """

    def __init__(self, server: str, project: str = None):
        self.tracking_context = oc.tracking()
        self.server_context = oc.api_server(server)
        self.project_context = oc.project(project) if project else None

    def __enter__(self):
        self.tracker = self.tracking_context.__enter__()
        self.server_context.__enter__()
        if self.project_context:
            self.project_context.__enter__()
        return self

    def __exit__(self, exc_type, exc: Exception, exc_trace):
        self.server_context.__exit__(
            exc_type, exc, exc_trace)
        if self.project_context:
            self.project_context.__exit__(
                exc_type, exc, exc_trace)

        self.tracker.__exit__(
            exc_type, exc, exc_trace)

        if exc:
            # Log the result of this execution
            logging.error(
                "Error running oc command. Results tracking: %s",
                self.tracker.get_result())

            if exc_type is OpenShiftPythonException:
                raise OcException.from_oc_exception(exc)
            elif _oc_not_found(exc):
                raise OcException.from_oc_not_found(exc)
            else:
                raise exc

        return True


def _oc_not_found(error: Exception):
    return (isinstance(error, FileNotFoundError) and
            error.filename == context.default_oc_path)


class OcException(Exception):

    @staticmethod
    def from_oc_exception(
            original_error: OpenShiftPythonException,
            main_message=None
    ):
        """
        Creates an OCException using
        an instance of the 3rd-party OpenShiftPythonException
        """
        result = original_error.get_result()
        if result:
            actions = result.actions()
            out_messages = [actions[0].out, actions[0].err]
        else:
            out_messages = []

        main_message = main_message or original_error.msg
        return OcException(main_message, out_messages)

    @staticmethod
    def from_oc_not_found(error: FileNotFoundError):
        """
        Creates an OCException when oc is not found
        """
        return OcException(
            "'oc' binary not found. "
            "Did your forget to install the OpenShift command-line tool?",
            [error.strerror])

    def __init__(self, message: str, messages: List[str] = []):
        self.message = message
        self.messages = [message] + messages
        super().__init__(self.message)

    def get_messages(self):
        return [m.replace("\n", "") for m in self.messages if m]

    def get_messages_as_dict(self):
        return [{"text": m for m in self.get_messages()}]


# Node object seems reduntant but it is needed for `cluster.until_all` of
# ocp client In this case we should have it in the method signature but do
# not use it
def node_obj_is_ready(node, obj_kind, obj_name, match_param={
    'type': 'Ready',
    'status': 'True',
}):
    ready = oc.selector(
        f"{obj_kind}/{obj_name}").object().model.status.can_match(match_param)
    return ready


def node_is_ready(node, match_param={
    'type': 'Ready',
    'status': 'True',
}):
    return node.model.status.conditions.can_match(match_param)
