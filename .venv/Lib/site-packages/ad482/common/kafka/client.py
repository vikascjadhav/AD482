from ad482.common.classroom import KafkaClassroomConfig
from typing import Any, Callable, TypeVar
import kafka as kafkalib
from . import serdes


class KafkaClient():
    _consumer: kafkalib.KafkaConsumer

    def __init__(
            self,
            bootstrap_server: str,
            bootstrap_port: int,
            cert_path: str,
            consumer_timeout_ms: float = None,
            value_deserializer=None,
            auto_offset_reset: str = 'earliest',
            enable_auto_commit: bool = False
    ) -> None:
        if consumer_timeout_ms is None:
            consumer_timeout_ms = float('inf')

        self._consumer = kafkalib.KafkaConsumer(
            bootstrap_servers=f"{bootstrap_server}:{bootstrap_port}",
            security_protocol='SSL',
            ssl_cafile=cert_path,
            auto_offset_reset=auto_offset_reset,
            enable_auto_commit=enable_auto_commit,
            consumer_timeout_ms=consumer_timeout_ms,
            value_deserializer=value_deserializer
        )

    def is_connected(self) -> bool:
        return self._consumer.bootstrap_connected()

    def topics_exist(self, topics) -> bool:
        return all(topic in self._consumer.topics() for topic in topics)

    def subscribe(self, topic) -> None:
        self._consumer.subscribe(topic)

    def unsubscribe(self) -> None:
        self._consumer.unsubscribe()

    def has_record_with_value(self, topic: str, value: dict) -> bool:
        self.subscribe(topic)
        found_record = False

        for message in self._consumer:
            if value.items() <= message.value.items():
                found_record = True

        return found_record

    def has_records_with_values(self, topic: str, values: list) -> bool:
        self.subscribe(topic)
        ref_num = 0
        for message in self._consumer:
            for value in values:
                if value.items() <= message.value.items():
                    ref_num = ref_num + 1

                if ref_num == len(values):
                    return True

        return False


T = TypeVar("T")


class KafkaPublisher():

    """
    Wraps the original KafkaProducer from kafka-python 3rd-party library
    """

    _producer: kafkalib.KafkaProducer

    @classmethod
    def from_config(
            cls,
            config: KafkaClassroomConfig,
            value_serializer: Callable[[T], bytes] = None,
            key_serializer: Callable[[T], bytes] = None):
        return cls(
            config.kafka_bootstrap_server,
            config.kafka_bootstrap_port,
            config.kafka_cert_path,
            value_serializer,
            key_serializer)

    def __init__(
        self,
        bootstrap_server: str,
        bootstrap_port: int,
        cert_path: str,
        value_serializer=None,
        key_serializer=None
    ):
        self._producer = kafkalib.KafkaProducer(
            bootstrap_servers=f"{bootstrap_server}:{bootstrap_port}",
            key_serializer=key_serializer,
            value_serializer=value_serializer or serdes.string_serializer,
            security_protocol="SSL",
            ssl_cafile=cert_path
        )

    def produce(self, topic: str, value: Any, key=None):
        self._producer.send(topic, value=value, key=key)
