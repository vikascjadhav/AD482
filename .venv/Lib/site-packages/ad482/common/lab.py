"""
This module provides utility functions for creating lab scripts
"""

import inspect
from abc import ABC
from functools import wraps
from typing import Callable, Dict, List, Union


def step(label, fatal=True, msgs: List[Dict[str, str]] = None):
    """
    Decorator to create lab steps as functions.

    The decorated function returns the dictionary
    that DynoLabs handles as a lab step.

    If decorated function raises a LabStepError,
    then dynolabs will consider the step as failed.

    The decorated function will also receive
    an option "labs_item" keyword argument,
    containing the dynolabs "item" dict.
    This is usefull to handle messages.

    You can override "label", "fatal" and "msgs"
    by just passing them as parameters to the decorated function call

        @labstep("My default label")
        some_step(configA, configB, label="My custom label")

    :param label: A label for the step
    :param fatal: Whether the step is fatal, in case of error
    :param msgs: List of additional messages
    """

    def decorator(func):

        @wraps(func)
        def wrapper_fn(*args, **decorated_kwargs):

            kwargs = {
                "label": label,
                "fatal": fatal,
                "msgs": msgs,
                # Decorated keyword args override the previous values
                **decorated_kwargs,
            }
            return as_lab_item_dict(func, *args, **kwargs)

        return wrapper_fn

    return decorator


def as_lab_item_dict(
    func: Callable, *func_args,
    label="", fatal=True, msgs: List[Dict[str, str]] = None,
    **func_kwargs
):
    """
    Wraps a funcion to be called by DynoLabs as a lab step.
    Returns the "item" dictionary expected by Dynolabs.

    :param func: The step function
    :param *func_args: Positional required arguments for "func"
    :param label: A label for the step
    :param fatal: Whether the step is fatal, in case of error
    :param msgs: List of additional messages
    :param **func_kwargs: Keyword arguments for "func"
    """
    original_parameters = inspect.signature(func).parameters

    def build_kwargs(item: Dict):
        kwargs = {}

        for parameter in original_parameters:
            if parameter == "labs_item":
                kwargs[parameter] = item
            elif parameter in func_kwargs:
                kwargs[parameter] = func_kwargs[parameter]

        return kwargs

    def task(item: Dict):
        """
        This is the task function executed by DynoLabs, as:
            item["task"](item)
        """
        kwargs = build_kwargs(item)
        try:
            func(*func_args, **kwargs)
        except TaskException as error:
            item["failed"] = True
            for m in error.msgs:
                item["msgs"].append(m)

    # The item dict to make DynoLabs happy
    item = {
        "task": task,
        "label": label,
        "fatal": fatal,
        "msgs": msgs or []
    }

    return item


class TaskException(Exception):
    msgs = []

    def __init__(self, msgs: Union[str, List[str]]):
        if isinstance(msgs, str):
            self.msgs = [msgs]
        else:
            self.msgs = msgs

        self.msgs = [{"text": msg} for msg in self.msgs]


class TaskResult(ABC):

    """
    Each task funcion should return an instance
    of this ABC (Abstract base class)
    """

    ok: bool
    msgs: List[str]

    def __init__(self, ok: bool, msgs: List[str] = None):
        self.ok = ok
        self.msgs = msgs or []

    def msgs_as_dicts(self):
        return [{"text": msg} for msg in self.msgs]


class TaskSuccess(TaskResult):

    def __init__(self, msgs: List[str] = None):
        return super().__init__(True, msgs)

    def __bool__(self):
        return True


class TaskFailure(TaskResult):

    def __init__(self, msgs: List[str] = None):
        return super().__init__(False, msgs)

    def __bool__(self):
        return False


TaskReturnValue = Union[TaskResult, bool, None]


def task(func: Callable[..., TaskReturnValue]):

    """
    This decorator wraps the call to the original function
    by accepting an "item" dictionary

    This decorator has less "magic" than the previous "step" decorator
    """

    @wraps(func)
    def wrapper(*args, **kwargs):

        def task(item: Dict):
            """
            This is the task function executed by DynoLabs, as:
                item["task"](item)
            """

            try:
                result = func(*args, **kwargs)

                # If, the function returns False, raise error
                if result is False:
                    raise TaskException()

                # If the function returns an instance of TaskResult
                # we parse the status and the msgs
                if isinstance(result, TaskResult):
                    item["msgs"] = result.msgs
                    if result.ok:
                        item["msgs"] = result.msgs_as_dicts()
                    else:
                        raise TaskException(result.msgs)

                # Otherwise, we consider the function as sucessful
                # (as long as the function does not raise TaskException)

            except TaskException as error:
                item["failed"] = True
                if "msgs" not in item:
                    item["msgs"] = []
                for m in error.msgs:
                    item["msgs"].append(m)

        return task

    return wrapper
