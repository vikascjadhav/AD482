"""
Common task functions ready to be reused in AD482 lab steps

These tasks should be as deocupled as possible from other modules as they
are potential candidates for rht-labs-core or other common libs
"""
import logging
import shutil
from ssl import SSLError

import ocpcli

from pathlib import Path
from typing import Dict, List, Union

from kafka.errors import KafkaError
from labs.common.git import repository
from ocpcli.client import OcException, node_is_ready, node_obj_is_ready
from .classroom import KafkaClassroomConfig, workspace
from .kafka.client import KafkaClient
from .lab import TaskSuccess, TaskException, task
from .kafka import get_kafka_client, is_state_store_name
from .kafka.config import KafkaConfig
from . import generate_project_name
from .constants import (
    APPS_DIR, COURSE_SKU, KAFKA_CLUSTER_NAME, KAFKA_CLUSTER_NS_SUFFIX,
    KUBEFILES_TEMPLATES_DIR, SERVICE_REGISTRY_DB_NAME,
    SERVICE_REGISTRY_DB_USER, SERVICE_REGISTRY_DB_PASSWORD, ERROR_NOT_FOUND)


@task
def create_env_files(workdir: str):
    kafka_config = KafkaConfig.from_workspace()

    filepath = Path(workdir).joinpath('.env')
    streams_filepath = Path(workdir).joinpath('.env-streams')

    bootstrap_server = (f'{kafka_config.bootstrap_server}'
                        + f':{kafka_config.bootstrap_port}')

    # Force forward slashes.
    # In Windows, Java understands the "/" dir separator.
    truststore_path = str(Path(workdir, "truststore.jks")).replace("\\", "/")

    with open(str(filepath), 'w') as env_file:
        env_file.writelines([
            f'kafka.bootstrap.servers={bootstrap_server}\n',
            'kafka.security.protocol=SSL\n',
            f'kafka.ssl.truststore.location={truststore_path}\n',
            'kafka.ssl.truststore.password=password\n',
            'quarkus.kafka.devservices.enabled=false\n'
        ])

    with open(str(streams_filepath), 'w') as env_file:
        env_file.writelines([
            f'kafka.bootstrap.servers={bootstrap_server}\n',
            'kafka.security.protocol=SSL\n',
            f'kafka.ssl.truststore.location={truststore_path}\n',
            'kafka.ssl.truststore.password=password\n',
            f'quarkus.kafka-streams.bootstrap-servers={bootstrap_server}\n',
            'quarkus.kafka.devservices.enabled=false\n'
        ])

    return TaskSuccess()


@task
def check_kafka_connection(kafka_config: KafkaConfig):
    kafka_config = kafka_config or KafkaConfig.from_workspace()

    if not Path(kafka_config.cert_path).exists():
        raise TaskException(
            f"Certificate not found: {kafka_config.cert_path}")

    kafka_client = _get_kafka_client_or_error(
        kafka_config.bootstrap_server,
        kafka_config.bootstrap_port,
        kafka_config.cert_path
    )

    msgs = [
        f"Bootstrap Server: {kafka_config.bootstrap_server}",
        f"Bootstrap Port: {kafka_config.bootstrap_port}",
        f"Path to Cluster Certificate: {kafka_config.cert_path}",
        f"Cluster Namespace: {kafka_config.cluster_namespace}"
    ]

    if not kafka_client.is_connected():
        raise TaskException("Unable to connect to the Kafka cluster")

    return TaskSuccess(msgs)


@task
def check_kafka_topics(topics: List[str], kafka_config: KafkaConfig):
    kafka_client = _get_kafka_client_or_error(
        kafka_config.bootstrap_server,
        kafka_config.bootstrap_port,
        kafka_config.cert_path
    )

    if not kafka_client.topics_exist(topics):
        raise TaskException(f"Unable to find the topic(s): {topics}")


@task
def at_least_one_record_with_json_value(topic: str, value,
                                        kafka_config: KafkaConfig):
    kafka_client = _get_kafka_client_or_error(
        kafka_config.bootstrap_server,
        kafka_config.bootstrap_port,
        kafka_config.cert_path
    )

    if not kafka_client.has_record_with_value(topic, value):
        raise TaskException(
            f"Unable to find record with value: {value} in topic {topic}"
        )


@task
def has_records_with_json_value(topic: str, values: list,
                                kafka_config: KafkaConfig,
                                consumer_timeout_ms=1000):
    kafka_client = _get_kafka_client_or_error(
        kafka_config.bootstrap_server,
        kafka_config.bootstrap_port,
        kafka_config.cert_path,
        consumer_timeout_ms=consumer_timeout_ms
    )

    if not kafka_client.has_records_with_values(topic, values):
        raise TaskException(
            f"Unable to find records with value(s): {values} in topic {topic}"
        )


@task
def create_kafka_cluster(cluster: str, broker_replicas: int,
                         ocp_api: str, ocp_username: str):
    project = _get_kafka_project_name_from_username(ocp_username)
    oc_client = ocpcli.get_oc_client(ocp_api)

    if broker_replicas == 1:
        trx_state_log_min_isr = broker_replicas
    else:
        trx_state_log_min_isr = broker_replicas - 1

    template_path = KUBEFILES_TEMPLATES_DIR.joinpath('cluster.yaml')

    template_parameters = {'CLUSTER_NAME': cluster,
                           'BROKER_REPLICAS': str(broker_replicas),
                           'ZK_REPLICAS': "1",
                           'TRX_STATE_LOG_MIN_ISR': str(
                               trx_state_log_min_isr)
                           }

    try:
        cluster = oc_client.apply_template(
            project,
            str(template_path),
            template_parameters
        )

        cluster.until_all(success_func=node_is_ready)
    except OcException as err:
        raise TaskException(err.get_messages())


# TODO: Renaming this method is a must, because it
#  deletes the project not the actual Kafka cluster

# TODO 2: Deleting the resources first will be a better idea
#  since project deletion can stuck
def delete_kafka_cluster(item: Dict):
    oc_client = ocpcli.get_oc_client(item['endpoint'])
    project = _get_kafka_project_name_from_username(
        item['username']
    )

    try:
        oc_client.delete_project(project)
    except OcException as e:
        item["failed"] = True
        item["msgs"] = e.get_messages_as_dict()
        return item


def store_kafka_credentials(item: Dict):
    oc_client = ocpcli.get_oc_client(item['endpoint'])

    project = _get_kafka_project_name_from_username(item['username'])

    # Getting the bootstrap route
    bootstrap_route = oc_client.get_route(
        project,
        name=f"{KAFKA_CLUSTER_NAME}-kafka-bootstrap",
        https_output=None
    )

    # Extracting the cluster certificate from OCP
    secret = oc_client.extract_secret(
        project,
        f"{KAFKA_CLUSTER_NAME}-cluster-ca-cert", 'ca.crt'
    )

    # Storing the certificate in the workspace
    certificate = Path(workspace.config.workdir).joinpath(
        'kafka-cluster.crt'
    )
    certificate.write_text(secret)

    # Generating the Kafka settings
    kafka_config = {
        'kafka_bootstrap_server': bootstrap_route,
        'kafka_bootstrap_port': 443,
        'kafka_cert_path': str(certificate),
        'kafka_cluster_namespace': project
    }

    ocp_config = vars(workspace.config)

    # Storing the Kafka settings in the config
    workspace.configure(
        KafkaClassroomConfig.from_dict(
            {**ocp_config, **kafka_config}
        ),
        False
    )


@task
def create_topics(
        topics: List[str],
        ocp_api: str,
        ocp_username: str,
        cluster: str,
        partitions=1,
        replication=1
):
    """
    Task to create a Kafka topic
    """
    template_path = KUBEFILES_TEMPLATES_DIR.joinpath("topic.yaml")
    project = _get_kafka_project_name_from_username(ocp_username)
    oc_client = ocpcli.get_oc_client(ocp_api)

    errors = []
    successfully_created_topics = []
    try:
        for topic in topics:
            (success, _, objs) = oc_client.apply_template_and_wait(
                project,
                template_path,
                {
                    "TOPIC_NAME": topic,
                    "CLUSTER_NAME": cluster,
                    "PARTITIONS": str(partitions),
                    "REPLICAS": str(replication)
                },
                failure_func=node_msg_contains_reason
            )

            if not success:
                raise OcException(
                    message=f"Failed to create the {topic} topic",
                    messages=node_msgs(objs))

            successfully_created_topics.append(topic)
    except OcException as err:
        errors.extend(err.get_messages())
    except Exception:
        errors.append("Error while creating topic")

    if len(errors) > 0:
        for topic in successfully_created_topics:
            try:
                oc_client.delete(project, "KafkaTopic", topic)
            except OcException as err:
                errors.append(f"Error while rolling back topic "
                              f"{topic}: {err.get_messages()}")
        raise TaskException(errors)


def node_msg_contains_reason(node) -> bool:
    """
    Assumption:
        .status.condition.reason only contain errors or warnings.

    Returns True if any .status.condition object contains reason.
    """
    conditions = node.model.status.get("conditions", [])
    failed_conditions = list(
        filter(lambda condition: bool(condition.get("reason", "")), conditions)
    )

    return len(failed_conditions) > 0


def node_msgs(objs) -> List[str]:
    """
    Returns a list of messages for each condition in the following format:
        .status.condition.reason: .status.condition.message
    """
    res = []
    for obj in objs:
        conditions = obj.model.status.get("conditions", [])
        res = res + [f"{condition.reason}: {condition.message}"
                     for condition in conditions]
    return res


@task
def delete_topics(topics: List[str],
                  ocp_api: str,
                  ocp_username: str):
    """
    Task to delete KafkaTopics via the oc client
    """
    project = _get_kafka_project_name_from_username(ocp_username)
    oc_client = ocpcli.get_oc_client(ocp_api)
    exceptions = []

    for topic in topics:
        try:
            oc_client.delete(project, "KafkaTopic", topic)
        except OcException as err:
            if ERROR_NOT_FOUND not in err.get_messages()[1]:
                # if one topic cannot be deleted, we still
                # want to attempt deleting other topics
                exceptions.append(err.get_messages())

    if len(exceptions) > 0:
        # err.get_messages gives a list; so exceptions
        # is a list of lists; sum flattens the list of lists
        raise TaskException(sum(exceptions, []))


@task
def create_service_registry_postgresql(project: str, ocp_api: str):
    oc_client = ocpcli.get_oc_client(ocp_api)

    database_service_name = "postgresql"

    template_path = KUBEFILES_TEMPLATES_DIR.joinpath('postgresql.yaml')
    template_parameters = {
        'DATABASE_SERVICE_NAME': database_service_name,
        'POSTGRESQL_DATABASE': SERVICE_REGISTRY_DB_NAME,
        'POSTGRESQL_USER': SERVICE_REGISTRY_DB_USER,
        'POSTGRESQL_PASSWORD': SERVICE_REGISTRY_DB_PASSWORD,
    }

    try:
        template = oc_client.apply_template(
            project,
            template_path,
            template_parameters,
        )

        template.until_all(obj_kind="deploymentconfig",
                           obj_name=database_service_name,
                           match_param={
                               'readyReplicas': 1,
                           },
                           success_func=node_obj_is_ready)
    except OcException as err:
        raise TaskException(err.get_messages())


@task
def create_service_registry(project: str, ocp_api: str):
    oc_client = ocpcli.get_oc_client(ocp_api)
    template_path = KUBEFILES_TEMPLATES_DIR.joinpath(
        'service-registry-sql.yaml')

    try:
        operator = oc_client.apply_template(
            project,
            str(template_path),
            {
                'DATABASE_NAMESPACE': project,
                'DATABASE_NAME': SERVICE_REGISTRY_DB_NAME,
                'DATABASE_USER': SERVICE_REGISTRY_DB_USER,
                'DATABASE_PASSWORD': SERVICE_REGISTRY_DB_PASSWORD
            }
        )
        operator.until_all(success_func=node_is_ready)
        # The operator creates ingress that spawns two routes.
        # The first one does not contain OCP router domain in the host.
        sr_url = _get_route_with_domain(project, ocp_api)
        msgs = [f"Service Registry URL: {sr_url}"]
    except OcException as err:
        raise TaskException(err.get_messages())

    return TaskSuccess(msgs)


def _get_route_with_domain(project: str, ocp_api: str) -> str:
    """
    This is a helper method to work around route that does not provide
    router domain. Gets the first route in the list of routes.
    Returns a string in the hostname.domain format.
    """
    oc_client = ocpcli.get_oc_client(ocp_api)
    routes = oc_client.get(project, "route", '')

    if not routes:
        raise OcException(message="No routes found")

    url = routes[0].model.spec.host
    domain = routes[0].model.status.ingress[0].routerCanonicalHostname
    return url if domain in url else f"{url}.{domain}"


@task
def create_connect_cluster(cluster: str,
                           image: str,
                           ocp_api: str,
                           ocp_username: str):
    """
    Task to create a KafkaConnect resource via the oc client
    """
    project = _get_kafka_project_name_from_username(ocp_username)
    oc_client = ocpcli.get_oc_client(ocp_api)

    template_path = KUBEFILES_TEMPLATES_DIR.joinpath('connect-cluster.yaml')

    try:
        cluster = oc_client.apply_template(
            project,
            template_path,
            {'CLUSTER_NAME': cluster,
             'BOOTSTRAP_SERVERS': f"{KAFKA_CLUSTER_NAME}-kafka-bootstrap:9092",
             'IMAGE': image}
        )

        cluster.until_all(success_func=node_is_ready)
    except OcException as err:
        raise TaskException(err.get_messages())


@task
def delete_connect_cluster(cluster: str,
                           ocp_api: str,
                           ocp_username: str):
    """
    Task to delete a KafkaConnect resource via the oc client
    """
    project = _get_kafka_project_name_from_username(ocp_username)
    oc_client = ocpcli.get_oc_client(ocp_api)

    try:
        oc_client.delete(project, "KafkaConnect", cluster)
    except OcException as err:
        if ERROR_NOT_FOUND not in err.get_messages()[1]:
            raise TaskException(err.get_messages())


@task
def delete_connect_connectors(connectors: List[str],
                              ocp_api: str,
                              ocp_username: str):
    """
    Task to delete KafkaTopics via the oc client
    """
    project = _get_kafka_project_name_from_username(ocp_username)
    oc_client = ocpcli.get_oc_client(ocp_api)
    exceptions = []

    try:
        for connector in connectors:
            oc_client.delete(project, "KafkaConnector", connector)
    except OcException as err:
        if ERROR_NOT_FOUND not in err.get_messages()[1]:
            exceptions.append(err.get_messages())

    if len(exceptions) > 0:
        raise TaskException(sum(exceptions, []))


@task
def create_elasticsearch_cluster(cluster: str,
                                 ocp_api: str,
                                 ocp_username: str):
    """
    Task to create a Elasticsearch resource via the oc client
    """
    project = _get_kafka_project_name_from_username(ocp_username)
    oc_client = ocpcli.get_oc_client(ocp_api)

    template_path = KUBEFILES_TEMPLATES_DIR.joinpath('elasticsearch.yaml')

    try:
        template = oc_client.apply_template(
            project,
            template_path,
            {'CLUSTER_NAME': cluster}
        )

        template.until_all(obj_kind="elasticsearch", obj_name=cluster,
                           match_param={
                               'phase': 'Ready',
                               'health': 'green',
                           },
                           success_func=node_obj_is_ready)
    except OcException as err:
        raise TaskException(err.get_messages())


@task
def delete_elasticsearch_cluster(cluster: str,
                                 ocp_api: str,
                                 ocp_username: str):
    """
    Task to delete a Elasticsearch resource via the oc client
    """
    project = _get_kafka_project_name_from_username(ocp_username)
    oc_client = ocpcli.get_oc_client(ocp_api)

    template_path = KUBEFILES_TEMPLATES_DIR.joinpath('elasticsearch.yaml')

    try:
        oc_client.delete_template(project,
                                  template_path,
                                  {'CLUSTER_NAME': cluster})
    except OcException as err:
        if ERROR_NOT_FOUND not in err.get_messages()[1]:
            raise TaskException(err.get_messages())


@task
def create_postgresql(database_service_name: str,
                      database_name: str,
                      init_sql_statements: str,
                      ocp_api: str,
                      ocp_username: str):
    """
    Task to create Postgresql relevant resources via the oc client
    """
    project = _get_kafka_project_name_from_username(ocp_username)
    oc_client = ocpcli.get_oc_client(ocp_api)

    template_path = KUBEFILES_TEMPLATES_DIR.joinpath('postgresql.yaml')
    template_parameters = {
        'DATABASE_SERVICE_NAME': database_service_name,
        'POSTGRESQL_DATABASE': database_name
    }

    if init_sql_statements is not None:
        template_parameters['INIT_SQL_STATEMENTS'] = init_sql_statements

    try:
        template = oc_client.apply_template(
            project,
            template_path,
            template_parameters,
        )

        template.until_all(obj_kind="deploymentconfig",
                           obj_name=database_service_name,
                           match_param={
                               'readyReplicas': 1,
                           },
                           success_func=node_obj_is_ready)
    except OcException as err:
        raise TaskException(err.get_messages())


@task
def delete_postgresql(database_service_name: str,
                      ocp_api: str,
                      ocp_username: str):
    """
    Task to delete a Postgresql relevant resources via the oc client
    """
    project = _get_kafka_project_name_from_username(ocp_username)
    oc_client = ocpcli.get_oc_client(ocp_api)

    template_path = KUBEFILES_TEMPLATES_DIR.joinpath('postgresql.yaml')

    try:
        oc_client.delete_template(project,
                                  template_path,
                                  {
                                      'DATABASE_SERVICE_NAME':
                                          database_service_name})
    except OcException as err:
        if ERROR_NOT_FOUND not in err.get_messages()[1]:
            raise TaskException(err.get_messages())


@task
def apply_resource(resource_path: str,
                   status_check_match_param: dict,
                   ocp_api: str,
                   ocp_username: str):
    """
    Task to create Postgresql relevant resources via the oc client
    """
    project = _get_kafka_project_name_from_username(ocp_username)
    oc_client = ocpcli.get_oc_client(ocp_api)

    try:
        resource = oc_client.apply(project, resource_path)

        if status_check_match_param is not None:
            resource.until_all(match_param=status_check_match_param,
                               success_func=node_obj_is_ready)
    except OcException as err:
        raise TaskException(err.get_messages())


@task
def pull_apps_repo():
    """
    Task to runs "git pull" on the workspace/AD482-apps local folder
    """
    reponame = f"{COURSE_SKU}-apps"
    try:
        repopath = workspace.path(reponame)
        repository.pull(repopath)
    except repository.GitRepoError as err:
        raise TaskException([
            f"Error pulling from the {reponame} repository",
            str(err)
        ])


@task
def copy_lab_files(
        app_dir_path: Union[Path, str],
        destination: Union[Path, str]
):
    """
    Copy lab files from:
        workspace/AD482-apps/{source}
    to:
        workspace/{destination}

    :param app_dir_path: Relative to workspace/APPS_DIR
    :param destination: Relative to workspace/
    """

    try:
        workspace.copy_subdir(
            Path(APPS_DIR, app_dir_path),
            destination
        )
    except Exception as err:
        raise TaskException([
            "Error copying lab files to workspace",
            str(err)
        ])

    return TaskSuccess([
        f"Lab files copied to {workspace.path(destination)}"
    ])


@task
def copy_file(
        filename: Union[Path, str],
        destination: Union[Path, str],
):
    """
    Copy file from:
        workspace/{filename}
    to:
        workspace/{destination}

    :param app_dir_path: Relative to workspace/APPS_DIR
    :param destination: Relative to workspace/
    """
    try:
        workspace_source = workspace.path(filename)
        workspace_destination = workspace.path(destination)
        shutil.copy(workspace_source, workspace_destination)
    except Exception as err:
        raise TaskException([
            "Error copying file",
            str(err)
        ])

    return TaskSuccess([
        f"{workspace_source} copied to {workspace_destination}"
    ])


@task
def resource_matches_specification(resource_name: str, resource_type: str,
                                   match_params: dict):
    project = _get_kafka_project_name_from_username(
        workspace.config.ocp_username
    )

    oc_client = ocpcli.get_oc_client(
        workspace.config.ocp_api
    )

    resource_list = oc_client.get(
        project,
        resource_type,
        resource_name
    )

    if not resource_list:
        raise TaskException(
            f"`{resource_type}` with the name `{resource_name}`"
            " must be created")

    for match_key, expected_value in match_params.items():
        result_value = eval(match_key, resource_list[0].model)

        if result_value != expected_value:
            raise TaskException(
                f"Configured `{match_key}` must be: `{expected_value}`")


# TODO: Need to delete this method to use the preceding method above.
@task
def topic_matches_specification(topic_name: str, partitions: int = None,
                                replicas: int = None, retention_ms: int = None,
                                segment_bytes: int = None):
    project = _get_kafka_project_name_from_username(
        workspace.config.ocp_username
    )

    oc_client = ocpcli.get_oc_client(
        workspace.config.ocp_api
    )

    topic = oc_client.get(
        project,
        'KafkaTopic',
        topic_name
    )

    if partitions is not None and \
            (partitions != topic[0].model.spec.partitions):
        raise TaskException(f"Configured partitions must be: {partitions}")

    if replicas is not None and (replicas != topic[0].model.spec.replicas):
        raise TaskException(f"Configured replicas must be: {replicas}")

    if segment_bytes is not None and \
            (segment_bytes != int(
                topic[0].model.spec.config['segment.bytes']
            )):
        raise TaskException(
            f"Configured segment bytes must be : {segment_bytes}"
        )

    if retention_ms is not None and \
            (retention_ms != int(topic[0].model.spec.config['retention.ms'])):
        raise TaskException(
            f"Configured retention must be : {retention_ms}")


@task
def check_file_exists(file_path: Path):
    if not file_path.exists():
        raise TaskException(
            f"File not found: {str(file_path)}")


@task
def check_file_contains(file_path: Path, value):
    with open(file_path, 'r') as file:
        if str(value) not in file.read():
            raise TaskException(f"Unable to find the value: {value}")


@task
def delete_state_stores(state_store_names, ocp_api: str, ocp_username: str):
    state_store_topics = []

    project = _get_kafka_project_name_from_username(ocp_username)
    oc_client = ocpcli.get_oc_client(ocp_api)

    for topic in oc_client.get(project, 'KafkaTopic', None):
        topic_name = topic.name()

        if is_state_store_name(topic_name, state_store_names):
            state_store_topics.append(topic_name)

    subtask = delete_topics(state_store_topics, ocp_api, ocp_username)
    subtask({})


@task
def move_to_kafka_namespace(ocp_api: str, ocp_username: str):
    namespace = _get_kafka_project_name_from_username(ocp_username)
    oc_client = ocpcli.get_oc_client(ocp_api)

    oc_client.set_project(namespace)


# Private functions


def _get_kafka_project_name_from_username(username: str) -> str:
    return generate_project_name(username, KAFKA_CLUSTER_NS_SUFFIX)


def _get_kafka_client_or_error(bootstrap_server: str,
                               bootstrap_port: int,
                               cert_path: str,
                               consumer_timeout_ms=1000) -> KafkaClient:
    try:
        return get_kafka_client(bootstrap_server, bootstrap_port, cert_path,
                                consumer_timeout_ms)
    except KafkaError as e:
        raise TaskException(str(e))
    except SSLError as e:
        raise TaskException(f"Error while verifying your SSL credentials: "
                            f"{e.reason}")
    except Exception as e:
        msg = "Error while creating the Kafka client"
        logging.debug(msg, e)
        raise TaskException(msg)
