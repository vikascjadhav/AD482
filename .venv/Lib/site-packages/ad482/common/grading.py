from pathlib import Path
from typing import List

from . import tasks
from .classroom import workspace
from .kafka.config import KafkaConfig


def verify_state_store_topics(topics: List[str], topic_prefix: str,
                              topic_suffix: str):
    for i, topic_name in enumerate(topics):
        topics[i] = topic_prefix + topic_name + topic_suffix

    return {
        "label": "Checking Kafka state store topics",
        "task": tasks.check_kafka_topics(topics, KafkaConfig.from_workspace()),
        "grading": True,
        "fatal": True,
    }


def verify_at_least_one_record_with_json_value(topic: str, value: dict):
    return {
        "label": f"Checking records in {topic} topic",
        "task": tasks.at_least_one_record_with_json_value(
            topic, value, KafkaConfig.from_workspace()
        ),
        "grading": True,
        "fatal": True,
    }


def verify_has_records_with_json_value(topic: str, values: list,
                                       consumer_timeout_ms=1000):
    return {
        "label": f"Checking records in {topic} topic",
        "task": tasks.has_records_with_json_value(
            topic, values, KafkaConfig.from_workspace(), consumer_timeout_ms
        ),
        "grading": True,
        "fatal": True,
    }


def verify_topics(topics: List[str]):
    return {
        "label": "Checking Kafka topics",
        "task": tasks.check_kafka_topics(topics, KafkaConfig.from_workspace()),
        "fatal": True,
        "grading": True
    }


def check_connect_cluster_specifications(resource_name: str,
                                         match_params: dict):
    match_params["status.conditions[0].type"] = "Ready"

    return {
        "label": f"Checking the connect cluster specifications: "
                 f"{resource_name}",
        "task": tasks.resource_matches_specification(resource_name,
                                                     "KafkaConnect",
                                                     match_params),
        "fatal": True,
        "grading": True
    }


def check_connect_connector_specifications(resource_name: str,
                                           match_params: dict):
    match_params["status.connectorStatus.connector.state"] = "RUNNING"

    return {
        "label": f"Checking the connector specifications: {resource_name}",
        "task": tasks.resource_matches_specification(resource_name,
                                                     "KafkaConnector",
                                                     match_params),
        "fatal": True,
        "grading": True
    }


# TODO: Need to refactor this method to use the preceding style above.
def check_topic_specifications(topic_name: str, partitions: int = None,
                               replicas: int = None, retention_ms: int = None,
                               segment_bytes: int = None):
    return {
        "label": "Checking the topic specifications",
        "task": tasks.topic_matches_specification(
            topic_name,
            partitions=partitions,
            replicas=replicas,
            retention_ms=retention_ms,
            segment_bytes=segment_bytes
        ),
        "fatal": True,
        "grading": True
    }


def check_file_exists_in_folder(file_name: str, folder: str):
    file_path = Path(workspace.config.workdir) \
        .joinpath(folder).joinpath(file_name)

    return {
        "label": f"Checking if the file {str(file_path)} exists",
        "task": tasks.check_file_exists(file_path),
        "fatal": True,
        "grading": True
    }


def check_file_in_folder_contains(file_name: str, folder: str, value):
    file_path = Path(workspace.config.workdir) \
        .joinpath(folder).joinpath(file_name)

    return {
        "label": f"Checking if the file {file_name} contains {value}",
        "task": tasks.check_file_contains(file_path, value),
        "fatal": True,
        "grading": True
    }
