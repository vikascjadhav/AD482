import requests
from pathlib import Path

from labs.common.userinterface import Console
from labs.grading import Default as Lab
from ad482.common import prechecks, sse, steps


BACKEND_URL = "http://localhost:8080"


class StreamsBuilding(Lab):

    """
    LAB: Building Applications with the Streams API
    """

    __LAB__ = "streams-building"

    topics = [
        "turbines",
        "turbine-generated-watts",
        "turbine-generated-mwatts",
        "turbine-stats",
    ]

    state_store_topics = [
        'earnings-aggregated',
        'expenses-aggregated',
        'wind-turbine-average-earnings',
        'wind-turbine-average-expenses'
    ]

    def start(self):
        prechecks.verify_config()
        items = [
            steps.pull_apps_repo(),
            steps.copy_lab_files(Path(self.__LAB__, "apps"), self.__LAB__),
            steps.copy_env_file(Path(self.__LAB__, "energy-meter")),
            steps.check_ocp_api(),
            steps.check_ocp_credentials(),
            steps.move_to_kafka_cluster_namespace(),
            steps.check_kafka_connection(),
            steps.create_topics(self.topics)
        ]

        Console(items).run_items(action="Starting")

    def grade(self):
        items = [
            {
                "label": "The backend app returns a 200 status code ",
                "task": app_endpoint_returns_200_status_code,
                "grading": True,
                "fatal": True
            },
            {
                "label": "The backend app exposes the turbines table store",
                "task": app_exposes_turbines_table,
                "grading": True,
                "fatal": True
            },
            {
                "label": "The backend app exposes the MWatts stream",
                "task": app_exposes_power_values,
                "grading": True,
                "fatal": True
            },
            {
                "label": "The backend app exposes the counts stream",
                "task": app_exposes_stats,
                "grading": True,
                "fatal": True
            }

        ]
        Console(items).run_items(action="Grading")

    def finish(self):
        items = [
            steps.check_ocp_api(),
            steps.check_ocp_credentials(),
            steps.move_to_kafka_cluster_namespace(False),
            steps.delete_topics(self.topics),
            steps.delete_state_store_topics([
                "energy-meter-streams-turbines-store",
                "energy-meter-streams-kstream-aggregate-state-store"
            ])
        ]
        Console(items).run_items(action="Finishing")


def app_endpoint_returns_200_status_code(item):
    try:
        r = requests.get(f"{BACKEND_URL}/turbines")
        r.url
        assert r.status_code == 200, (
            f"{r.url} returned status code {r.status_code}"
        )
    except (requests.exceptions.ConnectionError, AssertionError) as err:
        item["msgs"] = [{"text": str(err)}]
        item["failed"] = True


def app_exposes_turbines_table(item):
    turbines = requests.get(f"{BACKEND_URL}/turbines").json()

    try:
        assert len(turbines) == 3, (
            "/turbines does not return 3 turbines"
        )
    except AssertionError as err:
        item["msgs"] = [{"text": str(err)}]
        item["failed"] = True


def app_exposes_power_values(item):
    url = f"{BACKEND_URL}/turbines/generated-power"
    try:
        with requests.get(url, stream=True, timeout=10) as response:
            for value_bytes in response:
                data = sse.parse_json(value_bytes)
                if data and "turbineId" in data and "megawatts" in data:
                    response.close()
                    return

            raise RuntimeError("Stream ended")

    except (RuntimeError, requests.exceptions.ConnectionError) as err:
        item["failed"] = True
        item["msgs"] = [
            {"text": f"No values received from '{url}'"},
            {"text": str(err)}
        ]


def app_exposes_stats(item):
    url = f"{BACKEND_URL}/turbines/measurements-count"
    try:
        with requests.get(url, stream=True, timeout=60) as response:
            for value_bytes in response:
                data = sse.parse_json(value_bytes)
                if data and "turbineId" in data and "count" in data:
                    response.close()
                    return

            raise RuntimeError("Stream ended")

    except (RuntimeError, requests.exceptions.ConnectionError) as err:
        item["failed"] = True
        item["msgs"] = [
            {"text": f"No values received from '{url}'"},
            {"text": str(err)}
        ]
