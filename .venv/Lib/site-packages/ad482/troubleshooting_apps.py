import os
from pathlib import Path
import requests
from labs.grading import Default as Lab
from labs.common.userinterface import Console
from ad482.common import kafka, prechecks, sse, steps
from labs.common.tasks import check_command_result
from ad482.common.kafka import serdes
from ad482.common.classroom import workspace


TURBINES_TOPIC = "turbines"
BACKEND_URL = "http://localhost:8080"


class TroubleShootingApps(Lab):

    """
    LAB: Troubleshooting AMQ Streams Applications
    """

    __LAB__ = "troubleshooting-apps"

    topics = [
        TURBINES_TOPIC,
        "turbine-generated-watts",
        "turbine-wind-speed",
        "turbine-generated-mwatts",
        "turbine-stats"
    ]

    def start(self):
        prechecks.verify_config()
        items = [
            steps.pull_apps_repo(),
            steps.copy_lab_files(Path(self.__LAB__, "apps"), self.__LAB__),
            steps.copy_env_file(
                Path(self.__LAB__, "energy-meter", ".env"),
                filename=".env-streams"),
            steps.check_ocp_api(),
            steps.check_ocp_credentials(),
            steps.move_to_kafka_cluster_namespace(),
            steps.check_kafka_connection(),
            steps.create_topics(self.topics),
            {
                "label": f"Producing turbines to '{TURBINES_TOPIC}' topic",
                "task": produce_turbines,
                "fatal": True
            }
        ]
        Console(items).run_items(action="Starting")

    def finish(self):
        items = [
            steps.check_ocp_api(),
            steps.check_ocp_credentials(),
            steps.move_to_kafka_cluster_namespace(False),
            steps.delete_topics(self.topics),
            steps.delete_state_store_topics([
                "energy-meter-troubleshooting-turbines-store",
                "energy-meter-troubleshooting-kstream-aggregate-state-store",
                "energy-meter-troubleshooting-ktable"
            ]),
        ]
        Console(items).run_items(action="Finishing")

    def grade(self):
        items = [
            {
                "label": "The energy meter backend returns a 200 status code ",
                "task": app_endpoint_returns_200_status_code,
                "fatal": True
            },
            {
                "label": "The energy meter backend exposes the MWatts stream",
                "task": app_exposes_power_values,
                "fatal": True
            },
            {
                "label": "The energy meter reports 10 measurements per window",
                "task": app_exposes_10_measurements_per_second,
                "grading": True,
                "fatal": True
            },
            {
                "label": "Unit tests pass",
                "task": check_command_result,
                "command": (
                    workspace.path(Path(
                        "troubleshooting-apps",
                        "energy-meter",
                        "mvnw.cmd" if os.name == "nt" else "mvnw")),
                    "test"
                ),
                "cwd": workspace.path(Path(
                    "troubleshooting-apps",
                    "energy-meter")),
                "returns": 0,
                "prints": "Tests run: 1, Failures: 0, Errors: 0, Skipped: 0",
                "err_message": ("Tests failed. Run './mvnw test' in the"
                                " service directory for more details."),
                "grading": True,
                "fatal": True
            }

        ]
        Console(items).run_items(action="Grading")


class WindTurbine:

    id: int
    description: str
    power_capacity: int
    cutout_windspeed: int

    def __init__(
        self, id: int,
        description: str,
        power_capacity: int,
        cutout_wind_speed: int
    ) -> None:
        self.id = id
        self.description = description
        self.power_capacity = power_capacity
        self.cutout_windspeed = cutout_wind_speed

    def as_record(self):
        return (
            self.id,
            {
                "id": self.id,
                "description": self.description,
                "powerCapacity": self.power_capacity,
                "cutOutWindSpeed": self.cutout_windspeed
            }
        )


def app_endpoint_returns_200_status_code(item):
    try:
        r = requests.get(f"{BACKEND_URL}/turbines")
        r.url
        assert r.status_code == 200, (
            f"{r.url} returned status code {r.status_code}"
        )
    except (requests.exceptions.ConnectionError, AssertionError) as err:
        item["msgs"] = [{"text": str(err)}]
        item["failed"] = True


def produce_turbines(item: dict):
    item["msgs"] = []
    turbines = [
        WindTurbine(1, "Wind Turbine A", 2000000, 50),
        WindTurbine(2, "Wind Turbine B", 2500000, 55),
        WindTurbine(3, "Wind Turbine C", 3000000, 58),
    ]

    def callback(topic, record):
        item["msgs"].append({
            "text": f"Registered turbine {record}"
        })

    kafka.produce_many(
        TURBINES_TOPIC,
        [t.as_record() for t in turbines],
        workspace.config,
        key_serializer=serdes.int_serializer,
        value_serializer=serdes.json_serializer,
        sleep_seconds=0,
        callback=callback
    )


def app_exposes_power_values(item):
    url = f"{BACKEND_URL}/turbines/generated-power"
    try:
        with requests.get(url, stream=True, timeout=10) as response:
            for value_bytes in response:
                data = sse.parse_json(value_bytes)
                if data and "turbineId" in data and "megawatts" in data:
                    response.close()
                    return

            raise RuntimeError("Stream ended")

    except (RuntimeError, requests.exceptions.ConnectionError) as err:
        item["failed"] = True
        item["msgs"] = [
            {"text": f"No values received from the backend url:'{url}'"},
            {"text": str(err)}
        ]


def app_exposes_10_measurements_per_second(item):
    url = f"{BACKEND_URL}/turbines/measurements-count"

    # When all of them show a value of 10, the script passes
    counts = {
        1: 0,
        2: 0,
        3: 0
    }

    try:
        with requests.get(url, stream=True, timeout=60) as response:
            for value_bytes in response:
                data = sse.parse_json(value_bytes)
                if data and "turbineId" in data and "count" in data:
                    counts[data["turbineId"]] = data["count"]
                    if 3 == sum([count == 10 for count in counts.values()]):
                        response.close()
                        return

            raise RuntimeError("Stream ended")

    except (RuntimeError, requests.exceptions.ConnectionError) as err:
        item["failed"] = True
        msg = f"No correct values received from the backend url: '{url}'"
        item["msgs"] = [
            {"text": msg},
            {"text": str(err)}
        ]
