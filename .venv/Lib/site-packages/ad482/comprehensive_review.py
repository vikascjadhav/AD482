import json
import os
import requests

from pathlib import Path
from labs.grading import Default as GuidedExercise
from labs.common.userinterface import Console
from ad482.common import prechecks, steps, grading
from labs.common.tasks import check_command_result
from .common.constants import FILES_DIR, KAFKA_CONNECT_CLUSTER_NAME
from ad482.common.classroom import workspace

BACKEND_URL = "http://localhost:8081"


class ComprehensiveReview(GuidedExercise):
    __LAB__ = "comprehensive-review"

    """
    Comprehensive Review
    """

    sensors_topic_name = "garden-sensors"
    sensor_measurements_topic_name = "garden-sensor-measurements"
    sensor_measurements_repl_topic_name = "garden-sensor-measurements-repl"
    postgresql_db_instance_name = "postgresql"
    postgresql_db_name = "sensorsdb"
    sensors_connector_name = 'sensors-connector'
    app_name_garden_sensors = "garden-sensors"
    app_name_garden_back = "garden-back"
    app_name_garden_streams = "garden-streams"
    sensor_measurements_enriched_topic_name = \
        "garden-sensor-measurements-enriched"
    streams_topics = [
        sensor_measurements_enriched_topic_name,
        "garden-low-temperature-events",
        "garden-low-humidity-events",
        "garden-strong-wind-events",
        "garden-status-events"
    ]
    sensor_measurements_raw_check_items = [{"sensorId": 1, "type": "HUMIDITY"},
                                           {"sensorId": 2, "type": "HUMIDITY"},
                                           {"sensorId": 3, "type": "WIND"},
                                           {"sensorId": 4,
                                            "type": "TEMPERATURE"}]
    sensor_measurements_enriched_check_items = [
        {"sensorId": 4, "type": "TEMPERATURE", "sensorName": "PR 500",
         "gardenName": "Pablo's Garden"},
        {"sensorId": 3, "type": "WIND", "sensorName": "Nymbus 2001",
         "gardenName": "Aykut and Enol's Garden"},
        {"sensorId": 2, "type": "HUMIDITY", "sensorName": "RHOCP 4.8",
         "gardenName": "Marek's Garden"},
        {"sensorId": 1, "type": "HUMIDITY", "sensorName": "Dynolabs 2000",
         "gardenName": "Jaime's Garden"}
    ]

    def start(self):
        prechecks.verify_config()
        items = [
            steps.pull_apps_repo(),
            steps.copy_lab_files(f"{self.__LAB__}/apps", self.__LAB__),
            steps.copy_env_file(
                Path(f"{self.__LAB__}/{self.app_name_garden_sensors}")),
            steps.copy_env_file(
                Path(f"{self.__LAB__}/{self.app_name_garden_back}")),
            steps.copy_env_file(
                Path(f"{self.__LAB__}/{self.app_name_garden_streams}")),
            steps.check_ocp_api(),
            steps.check_ocp_credentials(),
            steps.check_kafka_connection(),
            steps.create_topics([
                self.sensors_topic_name,
                self.sensor_measurements_topic_name,
                self.sensor_measurements_repl_topic_name
            ] + self.streams_topics),
            steps.create_postgresql_from_file(
                self.postgresql_db_instance_name,
                self.postgresql_db_name,
                FILES_DIR.joinpath(self.__LAB__,
                                   "postgresql-sensors.sql")
            ),
            steps.create_connect_cluster(KAFKA_CONNECT_CLUSTER_NAME,
                                         "quay.io/redhattraining/ad482-"
                                         "ch05s08-connect-cluster:latest"),
            steps.create_ocp_projects([self.__LAB__]),
            steps.create_service_registry_postgresql(self.__LAB__),
            steps.create_service_registry(self.__LAB__),
            steps.move_to_kafka_cluster_namespace()
        ]
        Console(items).run_items(action="Starting")

    def finish(self):
        items = [
            steps.check_ocp_api(),
            steps.check_ocp_credentials(),
            steps.delete_connect_connectors(
                [self.sensors_connector_name]),
            steps.delete_connect_cluster(KAFKA_CONNECT_CLUSTER_NAME),
            steps.delete_topics([
                'my-connect-cluster-configs',
                'my-connect-cluster-offsets',
                'my-connect-cluster-status',
                self.sensors_topic_name,
                self.sensor_measurements_topic_name,
                self.sensor_measurements_repl_topic_name
            ] + self.streams_topics),
            steps.delete_state_store_topics([
                "garden-"
            ]),
            steps.delete_postgresql(self.postgresql_db_instance_name),
            steps.delete_ocp_projects([self.__LAB__]),
        ]
        Console(items).run_items(action="Finishing")

    def grade(self):
        items = [
            grading.check_connect_connector_specifications(
                self.sensors_connector_name,
                {
                    "metadata.labels['strimzi.io/cluster']":
                        KAFKA_CONNECT_CLUSTER_NAME,
                    "metadata.name": self.sensors_connector_name,
                    "spec.config['plugin.name']": "pgoutput",
                    "spec.config['database.hostname']": "postgresql",
                    "spec.config['database.port']": 5432,
                    "spec.config['schema.include.list']": "public",
                    "spec.config['table.include.list']": "public.sensors",
                }),
            grading.verify_has_records_with_json_value(
                self.sensors_topic_name,
                [{"id": 1, "name": "Dynolabs 2000", "type": "Humidity",
                  "customer": "Jaime", "garden": "Jaime's Garden"},
                 {"id": 2, "name": "RHOCP 4.8", "type": "Humidity",
                  "customer": "Marek", "garden": "Marek's Garden"},
                 {"id": 3, "name": "Nymbus 2001", "type": "Wind",
                  "customer": "Aykut & Enol",
                  "garden": "Aykut and Enol's Garden"},
                 {"id": 4, "name": "PR 500", "type": "Temperature",
                  "customer": "Pablo", "garden": "Pablo's Garden"}],
                consumer_timeout_ms=10000),
            grading.verify_has_records_with_json_value(
                self.sensor_measurements_repl_topic_name,
                self.sensor_measurements_raw_check_items,
                consumer_timeout_ms=10000
            ),
            {
                "label": "Unit tests pass",
                "task": check_command_result,
                "command": (
                    workspace.path(Path(
                        self.__LAB__,
                        self.app_name_garden_streams,
                        "mvnw.cmd" if os.name == "nt" else "mvnw")),
                    "test"
                ),
                "cwd": workspace.path(Path(
                    self.__LAB__,
                    self.app_name_garden_streams)),
                "returns": 0,
                "prints": "Tests run: 15, Failures: 0, Errors: 0, Skipped: 0",
                "err_message": ("Tests failed. Run './mvnw test' in the"
                                " service directory for more details."),
                "grading": True,
                "fatal": True
            },
            grading.verify_has_records_with_json_value(
                self.sensor_measurements_enriched_topic_name,
                self.sensor_measurements_enriched_check_items,
                consumer_timeout_ms=10000
            ),
            {
                "label": "Checking the backend app exposes the raw sensor "
                         "measurements",
                "task": app_exposes_sensor_measurements,
                "measurements": self.sensor_measurements_raw_check_items,
                "path": "/sensor/measurements/raw",
                "grading": True,
                "fatal": True
            },
            {
                "label": "Checking the backend app exposes the enriched "
                         "sensor measurements",
                "task": app_exposes_sensor_measurements,
                "measurements": self.sensor_measurements_enriched_check_items,
                "path": "/sensor/measurements/enriched",
                "grading": True,
                "fatal": True
            },
        ]
        Console(items).run_items(action="Grading")


def app_exposes_sensor_measurements(item):
    path = item["path"]
    measurements_req = requests.get(f"{BACKEND_URL}{path}",
                                    stream=True)

    measurements = item["measurements"]
    ref_num = 0

    try:
        for index, line in zip(range(10),
                               measurements_req.iter_lines(
                                   decode_unicode=True)):
            if line:
                for measurement in measurements:
                    if measurement.items() <= json.loads(
                            line.split(':', 1)[1]).items():
                        ref_num = ref_num + 1
        assert ref_num == len(measurements), (
            f"{path} does not return any records that matches"
        )
    except AssertionError as err:
        item["msgs"] = [{"text": str(err)}]
        item["failed"] = True
