"""
Common reusable tasks.
"""
import subprocess
from typing import Dict, Iterable, Tuple, Callable, Any
from . import labtools
from .workspace import Workspace
try:
    from .git import config as gitconfig
    from .git import repository
except ModuleNotFoundError:
    # Git is an optional dependency
    pass


# Define the type of a task
Task = Callable[[Dict], Any]


def check_workspace_exists(item: Dict):
    workspace: Workspace = item["workspace"]
    item["failed"] = not workspace.exists()


def mkdir(item: Dict):
    """
    Creates a folder

    :param item: dict containing: path
    """
    path: str = item["path"]

    result = labtools.mkdir(path)
    item.update(result)


def rmdir(item: Dict):
    """
    Removes a folder

    :param item: dict containing:path
    """
    path: str = item["path"]

    result = labtools.rmdir(path)
    item.update(result)


def check_git_config(item: Dict):
    """
    Checks if the user and the email are set in the git global config
    """

    item["failed"] = False
    item["msgs"] = []

    if not gitconfig.username():
        item["failed"] = True
        item["msgs"].append(
            {"text": "user.name not set"}
        )
    if not gitconfig.email():
        item["failed"] = True
        item["msgs"].append(
            {"text": "user.email not set"}
        )


def check_git_remote_points_to(item: Dict):
    """
    Checks whether a local repository has a remote url
    that points to remote_repo_name

    :param item: Dict containing
        repopath: absolute path of the local repository
        remote_repo_name: name of the remote repository.
            This function checks if the remoteURL includes this value
        name: name of the remote (optional)

        """
    repopath: str = item["repopath"]
    remote_repo_name: str = item["remote_repo_name"]
    name: str = item.get("name", "origin")

    tail = f"{remote_repo_name}.git"
    item["failed"] = True
    item["msgs"] = [
        {"text": f"{tail} not found in remote urls"}
    ]

    urls = []
    try:
        urls = repository.get_remote_urls(repopath, name)
    except Exception:
        urls = []

    for url in urls:
        if url.endswith(tail):
            item["failed"] = False
            item["msgs"] = []


def check_git_local_repo_exists(item):
    """
    Checks if a repository exists in a given local folder

    :param item: Dict containing
        repopath: name of the local repo folder
    """
    repopath: str = item["repopath"]

    if repository.exists(repopath):
        item["failed"] = False
        item["msgs"] = []
    else:
        item["failed"] = True
        item["msgs"] = [
            {"text": f"Repository does not exist at {repopath}"}
        ]


def grep(item):

    """
    Greps for content in a file, optionally ignoring cases.
    Fails if the content is not found

    :param item: Dict containing
        filepath
        content
        ignorecase (optional): False by default
    """

    filepath: str = item["filepath"]
    content: str = item["content"]
    ignorecase: bool = item.get("ignorecase", False)

    try:
        with open(filepath) as f:
            text = f.read()
            needle = content

            if ignorecase:
                text = text.lower()
                needle = content.lower()

            if needle in text:
                item["failed"] = False
            else:
                item["failed"] = True
                item["msgs"] = [{
                    "text": (f"{filepath} does not contain "
                                f"the following expected content: {content}")
                }]
    except OSError as error:
        item["failed"] = True
        item["msgs"] = [{
            "text": str(error)
        }]


def git(item: Dict):
    """
    Runs git commands

    :param item: Dict containing
        command: the git command as a list
        repopath
    """

    command: Iterable[str] = item.get("command", [])
    repopath: str = item["repopath"]

    try:
        repository.run(command[0], *command[1:], repodir=repopath)
        item["failed"] = False
    except repository.GitRepoError as error:
        # User tried to commit when there were no changes
        if "nothing to commit, working tree clean" in str(error).lower():
            item["failed"] = False
            item["msgs"] = [{
                "text": "Nothing to commit, skipping"
            }]
            return
        item["failed"] = True
        item["msgs"] = [{
            "text": str(error)
        }]


def check_command_result(item: Dict):
    """
    Runs a command and verifies its output and return code.

    :param item: Dict containing
        command: the git command
        cwd
        prints: Search this text in the output
        err_message: Message to use in case of error
        returns: Expected exit code
    """

    command: Tuple = item["command"]
    cwd: str = item.get("cwd")
    prints: str = item.get("prints")
    returns: str = item.get("returns")
    err_message: str = item.get("err_message")

    try:
        process = subprocess.Popen(
            command,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            cwd=cwd)
    except FileNotFoundError as err:
        item["failed"] = True
        item["msgs"] = [
            {"text": str(err)}
        ]
        return item

    stdout, stderr = process.communicate()

    try:
        if returns:
            assert returns == process.returncode, (
                f"Command did not exit with the {returns} code")

        if prints:
            assert prints in str(stdout), (
                f"'{prints}' not found in the command output")

        item["failed"] = False
    except AssertionError as err:
        item["failed"] = True
        item["msgs"] = []
        if err_message:
            item["msgs"].append({"text": err_message})

        item["msgs"].append({"text": str(err)})

        if stderr:
            item["msgs"].append({"text": f"Stderr: {stderr}"})
